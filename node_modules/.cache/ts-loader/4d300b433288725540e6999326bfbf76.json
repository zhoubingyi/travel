{"remainingRequest":"/Users/zhoubingyi/Desktop/travel/node_modules/babel-loader/lib/index.js!/Users/zhoubingyi/Desktop/travel/node_modules/ts-loader/index.js??ref--13-2!/Users/zhoubingyi/Desktop/travel/src/utils/request.ts","dependencies":[{"path":"/Users/zhoubingyi/Desktop/travel/src/utils/request.ts","mtime":1580733905312},{"path":"/Users/zhoubingyi/Desktop/travel/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/zhoubingyi/Desktop/travel/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/zhoubingyi/Desktop/travel/node_modules/ts-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["// 默认利用axios的cancelToken进行防重复提交。\n// 如需允许多个提交同时发出。则需要在请求配置config中增加 neverCancel 属性，并设置为true\nimport axios from 'axios'; // import store from '../store/index';\n// import { getSessionId } from '@/utils/auth';\n\n/* 防止重复提交，利用axios的cancelToken */\n\nvar pending = []; // 声明一个数组用于存储每个ajax请求的取消函数和ajax标识\n\nvar CancelToken = axios.CancelToken;\n\nvar removePending = function removePending(config, f) {\n  // 获取请求的url\n  var flagUrl = config.url; // 判断该请求是否在请求队列中\n\n  if (pending.indexOf(flagUrl) !== -1) {\n    // 如果在请求中，并存在f,f即axios提供的取消函数\n    if (f) {\n      f('取消重复请求'); // 执行取消操作\n    } else {\n      pending.splice(pending.indexOf(flagUrl), 1); // 把这条记录从数组中移除\n    }\n  } else {\n    // 如果不存在在请求队列中，加入队列\n    if (f) {\n      pending.push(flagUrl);\n    }\n  }\n};\n/* 创建axios实例 */\n\n\nvar service = axios.create({\n  timeout: 5000\n});\n/* request拦截器 */\n\nservice.interceptors.request.use(function (config) {\n  // neverCancel 配置项，允许多个请求\n  if (!config.neverCancel) {\n    // 生成cancelToken\n    config.cancelToken = new CancelToken(function (c) {\n      removePending(config, c);\n    });\n  } // 在这里可以统一修改请求头，例如 加入 用户 token 等操作\n  //   if (store.getters.sessionId) {\n  //     config.headers['X-SessionId'] = getSessionId(); // 让每个请求携带token--['X-Token']为自定义key\n  //   }\n\n\n  return config;\n}, function (error) {\n  console.log('error----', error);\n  Promise.reject(error);\n});\n/* respone拦截器 */\n\nservice.interceptors.response.use(function (response) {\n  // 移除队列中的该请求，注意这时候没有传第二个参数f\n  removePending(response.config); // 获取返回数据，并处理。按自己业务需求修改。下面只是个demo\n\n  var res = response.data;\n\n  if (res.code !== 200) {\n    if (res.code === 401) {\n      if (location.hash === '/') {\n        return res;\n      } else {\n        location.href = '/';\n      }\n    }\n\n    return Promise.reject('error');\n  } else {\n    return response.data;\n  }\n}, function (error) {\n  // 异常处理\n  console.log(error);\n  pending = [];\n\n  if (error.message === '取消重复请求') {\n    return Promise.reject(error);\n  }\n\n  return Promise.reject(error);\n});\nexport default service;",{"version":3,"sources":["/Users/zhoubingyi/Desktop/travel/src/utils/request.ts"],"names":[],"mappings":"AAAC;AACA;AAEA,OAAO,KAAP,MAAkB,OAAlB,C,CACA;AACA;;AAEA;;AACA,IAAI,OAAO,GAAU,EAArB,C,CAAyB;;AACzB,IAAM,WAAW,GAAQ,KAAK,CAAC,WAA/B;;AAIA,IAAM,aAAa,GAAQ,SAArB,aAAqB,CAAC,MAAD,EAAc,CAAd,EAAwB;AAC/C;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,GAAvB,CAF+C,CAG/C;;AACA,MAAI,OAAO,CAAC,OAAR,CAAgB,OAAhB,MAA6B,CAAC,CAAlC,EAAqC;AACjC;AACA,QAAI,CAAJ,EAAO;AACH,MAAA,CAAC,CAAC,QAAD,CAAD,CADG,CACU;AAChB,KAFD,MAEO;AACH,MAAA,OAAO,CAAC,MAAR,CAAe,OAAO,CAAC,OAAR,CAAgB,OAAhB,CAAf,EAAyC,CAAzC,EADG,CAC0C;AAChD;AACJ,GAPD,MAOO;AACH;AACA,QAAI,CAAJ,EAAO;AACH,MAAA,OAAO,CAAC,IAAR,CAAa,OAAb;AACH;AACJ;AACJ,CAjBD;AAkBA;;;AACA,IAAM,OAAO,GAAG,KAAK,CAAC,MAAN,CAAa;AACzB,EAAA,OAAO,EAAE;AADgB,CAAb,CAAhB;AAIA;;AACA,OAAO,CAAC,YAAR,CAAqB,OAArB,CAA6B,GAA7B,CAAiC,UAAC,MAAD,EAAgB;AAC7C;AACA,MAAI,CAAC,MAAM,CAAC,WAAZ,EAAyB;AACrB;AACA,IAAA,MAAM,CAAC,WAAP,GAAqB,IAAI,WAAJ,CAAgB,UAAC,CAAD,EAAW;AAC5C,MAAA,aAAa,CAAC,MAAD,EAAS,CAAT,CAAb;AACH,KAFoB,CAArB;AAGH,GAP4C,CAQ7C;AACA;AACA;AACA;;;AACA,SAAO,MAAP;AACH,CAbD,EAaG,UAAC,KAAD,EAAe;AACd,EAAA,OAAO,CAAC,GAAR,CAAY,WAAZ,EAAyB,KAAzB;AACA,EAAA,OAAO,CAAC,MAAR,CAAe,KAAf;AACH,CAhBD;AAkBA;;AACA,OAAO,CAAC,YAAR,CAAqB,QAArB,CAA8B,GAA9B,CACI,UAAC,QAAD,EAAkB;AACd;AACA,EAAA,aAAa,CAAC,QAAQ,CAAC,MAAV,CAAb,CAFc,CAGd;;AACA,MAAM,GAAG,GAAG,QAAQ,CAAC,IAArB;;AACA,MAAI,GAAG,CAAC,IAAJ,KAAa,GAAjB,EAAsB;AAClB,QAAI,GAAG,CAAC,IAAJ,KAAa,GAAjB,EAAsB;AAClB,UAAI,QAAQ,CAAC,IAAT,KAAkB,GAAtB,EAA2B;AACvB,eAAO,GAAP;AACH,OAFD,MAEO;AACH,QAAA,QAAQ,CAAC,IAAT,GAAgB,GAAhB;AACH;AACJ;;AACD,WAAO,OAAO,CAAC,MAAR,CAAe,OAAf,CAAP;AACH,GATD,MASO;AACH,WAAO,QAAQ,CAAC,IAAhB;AACH;AACJ,CAlBL,EAmBI,UAAC,KAAD,EAAe;AACX;AACA,EAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,EAAA,OAAO,GAAG,EAAV;;AACA,MAAI,KAAK,CAAC,OAAN,KAAkB,QAAtB,EAAgC;AAC5B,WAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACH;;AACD,SAAO,OAAO,CAAC,MAAR,CAAe,KAAf,CAAP;AACH,CA3BL;AA8BA,eAAe,OAAf","sourcesContent":[" // 默认利用axios的cancelToken进行防重复提交。\n // 如需允许多个提交同时发出。则需要在请求配置config中增加 neverCancel 属性，并设置为true\n\n import axios from 'axios';\n // import store from '../store/index';\n // import { getSessionId } from '@/utils/auth';\n\n /* 防止重复提交，利用axios的cancelToken */\n let pending: any[] = []; // 声明一个数组用于存储每个ajax请求的取消函数和ajax标识\n const CancelToken: any = axios.CancelToken;\n\n\n\n const removePending: any = (config: any, f: any) => {\n     // 获取请求的url\n     const flagUrl = config.url;\n     // 判断该请求是否在请求队列中\n     if (pending.indexOf(flagUrl) !== -1) {\n         // 如果在请求中，并存在f,f即axios提供的取消函数\n         if (f) {\n             f('取消重复请求'); // 执行取消操作\n         } else {\n             pending.splice(pending.indexOf(flagUrl), 1); // 把这条记录从数组中移除\n         }\n     } else {\n         // 如果不存在在请求队列中，加入队列\n         if (f) {\n             pending.push(flagUrl);\n         }\n     }\n };\n /* 创建axios实例 */\n const service = axios.create({\n     timeout: 5000, // 请求超时时间\n });\n\n /* request拦截器 */\n service.interceptors.request.use((config: any) => {\n     // neverCancel 配置项，允许多个请求\n     if (!config.neverCancel) {\n         // 生成cancelToken\n         config.cancelToken = new CancelToken((c: any) => {\n             removePending(config, c);\n         });\n     }\n     // 在这里可以统一修改请求头，例如 加入 用户 token 等操作\n     //   if (store.getters.sessionId) {\n     //     config.headers['X-SessionId'] = getSessionId(); // 让每个请求携带token--['X-Token']为自定义key\n     //   }\n     return config;\n }, (error: any) => {\n     console.log('error----', error)\n     Promise.reject(error);\n });\n\n /* respone拦截器 */\n service.interceptors.response.use(\n     (response: any) => {\n         // 移除队列中的该请求，注意这时候没有传第二个参数f\n         removePending(response.config);\n         // 获取返回数据，并处理。按自己业务需求修改。下面只是个demo\n         const res = response.data;\n         if (res.code !== 200) {\n             if (res.code === 401) {\n                 if (location.hash === '/') {\n                     return res;\n                 } else {\n                     location.href = '/';\n                 }\n             }\n             return Promise.reject('error');\n         } else {\n             return response.data;\n         }\n     },\n     (error: any) => {\n         // 异常处理\n         console.log(error);\n         pending = [];\n         if (error.message === '取消重复请求') {\n             return Promise.reject(error);\n         }\n         return Promise.reject(error);\n     },\n );\n\n export default service;\n"],"sourceRoot":""}]}